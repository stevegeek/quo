# Generated from lib/quo/composed_query.rb with RBS::Inline

module Quo
  module ComposedQuery
    # Combine two Query classes into a new composed query class
    # Combine two query-like or composeable entities:
    # These can be Quo::Query, Quo::ComposedQuery, Quo::CollectionBackedQuery and ActiveRecord::Relations.
    # See the `README.md` docs for more details.
    # @rbs chosen_superclass: singleton(Quo::RelationBackedQuery | Quo::CollectionBackedQuery)
    # @rbs left_query_class: singleton(Quo::Query | ::ActiveRecord::Relation)
    # @rbs right_query_class: singleton(Quo::Query | ::ActiveRecord::Relation)
    # @rbs joins: untyped
    # @rbs return: singleton(Quo::ComposedQuery)
    def composer: (untyped chosen_superclass, untyped left_query_class, untyped right_query_class, ?joins: untyped) -> singleton(Quo::ComposedQuery)

    include Quo::ComposedQuery

    attr_reader _composing_joins: untyped

    attr_reader _left_query: untyped

    attr_reader _right_query: untyped

    def self.inspect: () -> untyped

    # @rbs operand: Quo::ComposedQuery | Quo::Query | ::ActiveRecord::Relation
    # @rbs return: String
    def self.quo_operand_desc: (Quo::ComposedQuery | Quo::Query | ::ActiveRecord::Relation operand) -> String

    # We can also merge instance of prepared queries
    # @rbs left_instance: Quo::Query | ::ActiveRecord::Relation
    # @rbs right_instance: Quo::Query | ::ActiveRecord::Relation
    # @rbs joins: untyped
    # @rbs return: Quo::ComposedQuery
    def merge_instances: (Quo::Query | ::ActiveRecord::Relation left_instance, Quo::Query | ::ActiveRecord::Relation right_instance, ?joins: untyped) -> Quo::ComposedQuery

    # @rbs override
    def query: ...

    # @rbs override
    def inspect: ...

    private

    # The underlying query now needs to handle the possibilty of the return from the merge being either a relation or a collection
    def underlying_query: () -> ActiveRecord::Relation

    # The configured query is the underlying query with paging
    def configured_query: () -> ActiveRecord::Relation

    # @rbs return: Hash[Symbol, untyped]
    def child_options: (untyped query_class) -> Hash[Symbol, untyped]

    # @rbs return: Array[Symbol]
    def property_names: (untyped query_class) -> Array[Symbol]

    # @rbs return: Quo::Query | ::ActiveRecord::Relation
    def left: () -> (Quo::Query | ::ActiveRecord::Relation)

    # @rbs return: Quo::Query | ::ActiveRecord::Relation
    def right: () -> (Quo::Query | ::ActiveRecord::Relation)

    # @rbs return: ActiveRecord::Relation | CollectionBackedQuery
    def merge_left_and_right: () -> (ActiveRecord::Relation | CollectionBackedQuery)

    # @rbs left_rel: ActiveRecord::Relation
    # @rbs return: ActiveRecord::Relation
    def apply_joins: (ActiveRecord::Relation left_rel) -> ActiveRecord::Relation

    # @rbs rel: untyped
    # @rbs return: bool
    def is_relation?: (untyped rel) -> bool

    # @rbs left: untyped
    # @rbs right: untyped
    # @rbs return: bool
    def both_relations?: (untyped left, untyped right) -> bool

    # @rbs left: untyped
    # @rbs right: untyped
    # @rbs return: bool
    def left_relation_right_enumerable?: (untyped left, untyped right) -> bool

    # @rbs left: untyped
    # @rbs right: untyped
    # @rbs return: bool
    def left_enumerable_right_relation?: (untyped left, untyped right) -> bool
  end
end
